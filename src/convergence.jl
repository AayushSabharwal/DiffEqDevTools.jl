"""
ConvergenceSimulation

A type which holds the data from a convergence simulation.

### Fields

* `solutions::Array{<:DESolution}`: Holds all the PdeSolutions.
* `errors`: Dictionary of the error calculations. Can contain:

    - `h1Errors`: Vector of the H1 errors.
    - `l2Errors`: Vector of the L2 errors.
    - `maxErrors`: Vector of the nodal maximum errors.
    - `node2Errors`: Vector of the nodal l2 errors.

* `N`: The number of simulations.
* `auxdata`: Auxillary data of the convergence simluation. Entries can include:

    - `Œîts`: The Œît's in the simulations.
    - `Œîxs`: The Œîx's in the simulations.
    - `Œºs`: The CFL Œº's in the simulations.
    - `ŒΩs`: The CFL ŒΩ's in the simulations.

* `ùí™est`: Dictionary of order estimates. Can contain:

    - `ConvEst_h1`: The H1 error order of convergence estimate for the convergence simulation.
       Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
       the Œît/Œîx. If alternate scaling, modify by dividing of log(base,ConvEst_h1)
    - `ConvEst_l2`: The L2 error order of convergence estimate for the convergence simulation.
       Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
       the Œît/Œîx. If alternate scaling, modify by dividing of log(base,ConvEst_l2)
    - `ConvEst_max`: The nodal maximum error order of convergence estimate for the convergence simulation.
       Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
       the Œît/Œîx. If alternate scaling, modify by dividing of log(base,ConvEst_max)
    - `ConvEst_node2`: The nodal l2 error order of convergence estimate for the convergence simulation.
       Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
       the Œît/Œîx. If alternate scaling, modify by dividing of log(base,ConvEst_node2)

* `convergence_axis`: The axis along which convergence is calculated. For example, if
   we calculate the Œît convergence, convergence_axis is the Œîts used in the calculation.
"""
type ConvergenceSimulation{SolType<:DESolution}
  solutions::Array{SolType}
  errors
  N
  auxdata
  ùí™est
  convergence_axis
end

function ConvergenceSimulation(solutions,convergence_axis;auxdata=nothing)
  N = size(solutions,1)
  uEltype = eltype(solutions[1].u)
  errors = Dict() #Should add type information
  for k in keys(solutions[1].errors)
    errors[k] = reshape(uEltype[sol.errors[k] for sol in solutions],size(solutions)...)
  end
  ùí™est = Dict(map(calcùí™estimates,errors))
  ùí™esttmp = Dict() #Makes Dict of Any to be more compatible
  for (k,v) in ùí™est
    if length(v)==1 push!(ùí™esttmp,Pair(k,v[1]))
    else push!(ùí™esttmp,Pair(k,v))
    end
  end
  ùí™est = ùí™esttmp
  return(ConvergenceSimulation(solutions,errors,N,auxdata,ùí™est,convergence_axis))
end

"""
test_convergence(Œîts::AbstractArray,prob::AbstractSDEProblem)

Tests the strong order time convergence of the given algorithm on the given problem
solved over the given Œîts.

### Keyword Arguments

* `T`: The final time. Default is 1
* `numMonte`: The number of simulations for each Œît. Default is 10000.
* `save_timeseries`: Denotes whether to save at every timeseries_steps steps. Default is true.
* `timeseries_steps`: Denotes the steps to save at if `save_timeseries=true`. Default is 1
* `alg`: The algorithm to test. Defaults to "EM".
"""
function test_convergence(Œîts::AbstractArray,prob::AbstractSDEProblem;tspan=[0,1],numMonte=10000,save_timeseries=true,timeseries_steps=1,adaptive=false,kwargs...)
  N = length(Œîts)
  #solutions = DESolution[solve(prob::SDEProblem,Œîts[i],T,save_timeseries=save_timeseries,alg=alg) for j=1:numMonte,i=1:N]
  is = repmat(1:N,1,numMonte)'
  solutions = pmap((i)->solve(prob,tspan;Œît=Œîts[i],save_timeseries=save_timeseries,timeseries_steps=timeseries_steps,adaptive=adaptive,kwargs...),is)
  solutions = convert(Array{SDESolution},solutions)
  solutions = reshape(solutions,numMonte,N)
  auxdata = Dict("Œîts" =>  Œîts)
  ConvergenceSimulation(solutions,Œîts,auxdata=auxdata)
end

"""
test_convergence(Œîts::AbstractArray,prob::AbstractODEProblem)

Tests the order of the time convergence of the given algorithm on the given problem
solved over the given Œîts.

### Keyword Arguments

* `T`: The final time. Default is 1
* `save_timeseries`: Denotes whether to save at every timeseries_steps steps. Default is true.
* `timeseries_steps`: Denotes the steps to save at if `save_timeseries=true`. Default is 1
* `alg`: The algorithm to test. Defaults to "Euler".
* `tableau`: The tableau used for generic methods. Defaults to ODE_DEFAULT_TABLEAU.
"""
function test_convergence(Œîts::AbstractArray,prob::AbstractODEProblem;tspan=[0,1],save_timeseries=true,adaptive=false,kwargs...)
  N = length(Œîts)
  solutions = [solve(prob::ODEProblem,tspan;Œît=Œîts[i],save_timeseries=save_timeseries,adaptive=adaptive,kwargs...) for i=1:N]
  auxdata = Dict(:Œîts =>  Œîts)
  ConvergenceSimulation(solutions,Œîts,auxdata=auxdata)
end

"""
test_convergence(Œîts::AbstractArray,Œîxs::AbstractArray,prob::AbstractHeatProblem,convergence_axis)

Tests the convergence of the solver algorithm on the given Heat problem with
the Œîts and Œîxs as given. Uses the square mesh [0,1]x[0,1]. The convergence
axis is the axis along which convergence is calculated. For example, when testing
Œît convergence, `convergence_axis = Œîts`.

### Keyword Arguments

* `T`: The final time. Defaults to 1
* `alg`: The algorithm to test. Default is "Euler".
"""
function test_convergence(Œîts::AbstractArray,Œîxs::AbstractArray,prob::AbstractHeatProblem,convergence_axis;T=1,alg=:Euler)
  if length(Œîts)!=length(Œîxs) error("Lengths of Œîts!=Œîxs. Invalid convergence simulation") end
  solutions = [solve(parabolic_squaremesh([0 1 0 1],Œîxs[i],Œîts[i],T,:dirichlet),prob,alg=alg) for i in eachindex(Œîts)]
  auxdata = Dict(
            :Œîts => [sol.fem_mesh.Œît for sol in solutions],
            :Œîxs => [sol.fem_mesh.Œîx for sol in solutions],
            :ŒîŒºs => [sol.fem_mesh.Œº  for sol in solutions],
            :ŒîŒΩs => [sol.fem_mesh.ŒΩ  for sol in solutions])
  return(ConvergenceSimulation(solutions,convergence_axis,auxdata=auxdata))
end

"""
test_convergence(Œîxs::AbstractArray,prob::PoissonProblem)

Tests the convergence of the solver algorithm on the given Poisson problem with
Œîxs as given. Uses the square mesh [0,1]x[0,1].

### Keyword Arguments

* `solver`: Which solver to use. Default is "Direct".
"""
function test_convergence(Œîxs::AbstractArray,prob::AbstractPoissonProblem)
  solutions = [solve(notime_squaremesh([0 1 0 1],Œîxs[i],:dirichlet),prob,solver=:Direct) for i in eachindex(Œîxs)]
  auxdata = Dict("Œîxs" => [sol.fem_mesh.Œîx for sol in solutions])
  return(ConvergenceSimulation(solutions,Œîxs,auxdata=auxdata))
end



"""
calcùí™estimates(error::Vector{Number})

Computes the pairwise convergence estimate for a convergence test done by
halving/doubling stepsizes via

log2(error[i+1]/error[i])

Returns the mean of the convergence estimates
"""
function calcùí™estimates(error::Pair)
  key = error.first
  error =error.second
  if ndims(error)>1 error=mean(error,1) end
  S = Vector{eltype(error)}(length(error)-1)
  for i=1:length(error)-1
    S[i] = log2(error[i+1]/error[i])
  end
  return(Pair(key,abs.(mean(S,1))))
end

"""
length(simres::ConvergenceSimulation)

Returns the number of simultations in the Convergence Simulation
"""
Base.length(sim::ConvergenceSimulation) = sim.N
Base.endof( sim::ConvergenceSimulation) = length(sim)
Base.getindex(sim::ConvergenceSimulation,i::Int) = sim.solutions[i]
Base.getindex(sim::ConvergenceSimulation,i::Int,I::Int...) = sim.solutions[i][I]

function print(io::IO, sim::ConvergenceSimulation)
  println(io,"$(typeof(sim)) of length $(length(sim)).")
  print(io,"Convergence Estimates:")
  for (k,v) in sim.ùí™est
    print(" ($k,$v)")
  end
  println(io,"\n-----------Errors-----------")
  for (k,v) in sim.errors
    println(io,"$k: $v")
  end
end

function show(io::IO,sim::ConvergenceSimulation)
  println(io,"$(typeof(sim)) of length $(length(sim)).")
  print(io,"Convergence Estimates:")
  for (k,v) in sim.ùí™est
    print(io," ($k,$v)")
  end
end
